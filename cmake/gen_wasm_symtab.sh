#!/bin/sh
# gen_wasm_symtab.sh - Generate WASM symbol lookup table from .a files
# Usage: gen_wasm_symtab.sh <llvm-nm> <output.cpp> <lib1.a> [lib2.a ...]
# Filters to symbols needed by the Lean IR interpreter:
# - initialize_* : module init functions (called during import)
# - lean_*       : runtime C API (@[extern] implementations)
# - l_initFn*    : @[init] attribute functions
# - *___boxed    : boxed wrappers for @[extern] functions

LLVM_NM="$1"
OUTPUT="$2"
shift 2

SYMFILE=$(mktemp)
"$LLVM_NM" --defined-only "$@" 2>/dev/null \
    | awk '/^[0-9a-f]+ T / {print $3}' \
    | grep -E '^(initialize_|lean_|l_initFn)|___boxed$' \
    | sort -u > "$SYMFILE"
SYM_COUNT=$(wc -l < "$SYMFILE" | tr -d ' ')

echo "Generating WASM symbol table with $SYM_COUNT symbols" >&2

cat > "$OUTPUT" << 'HEADER'
// Auto-generated WASM symbol lookup table
// Do not edit - generated by gen_wasm_symtab.sh
#include <cstring>
#include <cstddef>

extern "C" {
HEADER

awk '{printf "    extern void %s();\n", $0}' "$SYMFILE" >> "$OUTPUT"

cat >> "$OUTPUT" << 'MIDDLE'
}

struct wasm_sym_entry {
    const char* name;
    void* addr;
};

static const wasm_sym_entry g_wasm_sym_table[] = {
MIDDLE

awk '{printf "    {\"%s\", (void*)&%s},\n", $0, $0}' "$SYMFILE" >> "$OUTPUT"

cat >> "$OUTPUT" << FOOTER
    {nullptr, nullptr}
};

static const size_t g_wasm_sym_table_size = ${SYM_COUNT};

// Binary search (table is sorted by name)
extern "C" void* wasm_lookup_symbol(const char* name) {
    size_t lo = 0, hi = g_wasm_sym_table_size;
    while (lo < hi) {
        size_t mid = lo + (hi - lo) / 2;
        int cmp = strcmp(g_wasm_sym_table[mid].name, name);
        if (cmp == 0) return g_wasm_sym_table[mid].addr;
        if (cmp < 0) lo = mid + 1;
        else hi = mid;
    }
    return nullptr;
}
FOOTER

rm -f "$SYMFILE"
echo "Generated: $OUTPUT ($SYM_COUNT symbols)" >&2
