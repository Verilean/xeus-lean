#############################################################################
# Copyright (c) 2025, xeus-lean contributors
#
# Distributed under the terms of the Apache Software License 2.0.
#
# The full license is in the file LICENSE, distributed with this software.
#############################################################################

# LeanRtWasm.cmake - Build libleanrt from lean4 source for WASM (emscripten)
#
# This module fetches the lean4 source and compiles the runtime (libleanrt)
# using emscripten. The lean4 runtime already has LEAN_EMSCRIPTEN guards
# throughout its source code (io.cpp, libuv.cpp, uv/*.cpp, object.cpp,
# platform.cpp, debug.cpp, stackinfo.cpp, process.cpp) that provide
# stub implementations for features not available in WASM.
#
# Usage:
#   include(LeanRtWasm)
#   fetch_and_build_leanrt(LEANRT_LIB LEAN4_INCLUDE_DIR)

include(FetchContent)

# Capture this module's directory before entering function scope
# (CMAKE_CURRENT_LIST_DIR inside a function resolves to the caller's dir)
set(_LEANRT_WASM_MODULE_DIR "${CMAKE_CURRENT_LIST_DIR}")

if(NOT DEFINED LEAN4_VERSION)
    set(LEAN4_VERSION "v4.28.0-rc1" CACHE STRING "Lean4 version tag to fetch")
endif()

function(fetch_and_build_leanrt out_lib out_include_dir)
    message(STATUS "Fetching lean4 source (${LEAN4_VERSION})...")

    FetchContent_Declare(
        lean4
        URL "https://github.com/leanprover/lean4/archive/refs/tags/${LEAN4_VERSION}.tar.gz"
    )

    FetchContent_GetProperties(lean4)
    if(NOT lean4_POPULATED)
        FetchContent_Populate(lean4)
    endif()

    set(LEAN4_SRC_DIR "${lean4_SOURCE_DIR}")
    set(LEAN4_RUNTIME_DIR "${LEAN4_SRC_DIR}/src/runtime")
    set(LEAN4_INCLUDE "${LEAN4_SRC_DIR}/src/include")

    message(STATUS "Lean4 source at: ${LEAN4_SRC_DIR}")
    message(STATUS "Lean4 runtime at: ${LEAN4_RUNTIME_DIR}")

    # --- Parse version from lean4's src/CMakeLists.txt ---
    file(READ "${LEAN4_SRC_DIR}/src/CMakeLists.txt" _lean_cmakelists)
    string(REGEX MATCH "set\\(LEAN_VERSION_MAJOR ([0-9]+)\\)" _ "${_lean_cmakelists}")
    set(_LEAN_MAJOR "${CMAKE_MATCH_1}")
    string(REGEX MATCH "set\\(LEAN_VERSION_MINOR ([0-9]+)\\)" _ "${_lean_cmakelists}")
    set(_LEAN_MINOR "${CMAKE_MATCH_1}")
    string(REGEX MATCH "set\\(LEAN_VERSION_PATCH ([0-9]+)\\)" _ "${_lean_cmakelists}")
    set(_LEAN_PATCH "${CMAKE_MATCH_1}")
    string(REGEX MATCH "set\\(LEAN_VERSION_IS_RELEASE ([01])\\)" _ "${_lean_cmakelists}")
    set(_LEAN_IS_RELEASE "${CMAKE_MATCH_1}")
    set(_LEAN_VERSION_STRING "${_LEAN_MAJOR}.${_LEAN_MINOR}.${_LEAN_PATCH}")
    message(STATUS "Lean4 version: ${_LEAN_VERSION_STRING}")

    # --- Generate version.h (normally generated by lean4's own CMake) ---
    file(WRITE "${LEAN4_INCLUDE}/lean/version.h" "
#pragma once
#define LEAN_VERSION_MAJOR ${_LEAN_MAJOR}
#define LEAN_VERSION_MINOR ${_LEAN_MINOR}
#define LEAN_VERSION_PATCH ${_LEAN_PATCH}
#define LEAN_VERSION_IS_RELEASE ${_LEAN_IS_RELEASE}
#define LEAN_SPECIAL_VERSION_DESC \"\"
#define LEAN_VERSION_STRING \"${_LEAN_VERSION_STRING}\"
#define LEAN_PLATFORM_TARGET \"wasm32-unknown-emscripten\"
#define LEAN_MANUAL_ROOT \"\"
")

    # --- Generate config.h for WASM build ---
    # Disable mimalloc (use emscripten's allocator instead)
    file(WRITE "${LEAN4_INCLUDE}/lean/config.h" [[
#pragma once
#include <lean/version.h>

/* WASM build: disable mimalloc, use emscripten allocator */
/* #undef LEAN_MIMALLOC */

#define LEAN_IS_STAGE0 0
]])

    # --- Generate githash.h (required by platform.cpp) ---
    file(WRITE "${LEAN4_SRC_DIR}/src/githash.h" [[
#pragma once
#define LEAN_GITHASH "emscripten-wasm-build"
]])

    # --- Patch thread.h for WASM single-threaded stubs ---
    # The single-threaded unique_lock stub is missing adopt_lock_t constructor
    # and release() method, which mutex.cpp requires.
    file(READ "${LEAN4_RUNTIME_DIR}/thread.h" _thread_h_content)
    string(REPLACE
        "unique_lock(T const &) {}\n    ~unique_lock() {}\n    void lock() {}\n    void unlock() {}"
        "unique_lock(T const &) {}\n    template<typename Tag> unique_lock(T const &, Tag) {}\n    ~unique_lock() {}\n    void lock() {}\n    void unlock() {}\n    void release() {}"
        _thread_h_content "${_thread_h_content}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/thread.h" "${_thread_h_content}")

    # --- Patch event_loop.h: return type mismatch for LEAN_EMSCRIPTEN stub ---
    # Header declares lean_uv_event_loop_alive() -> uint8_t outside the guard,
    # but the LEAN_EMSCRIPTEN stub in event_loop.cpp returns lean_obj_res.
    # Fix the header to match the stub.
    file(READ "${LEAN4_RUNTIME_DIR}/uv/event_loop.h" _evloop_h)
    string(REPLACE
        "extern \"C\" LEAN_EXPORT uint8_t lean_uv_event_loop_alive();"
        "extern \"C\" LEAN_EXPORT lean_obj_res lean_uv_event_loop_alive();"
        _evloop_h "${_evloop_h}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/uv/event_loop.h" "${_evloop_h}")

    # --- Patch tcp.cpp: add missing LEAN_EMSCRIPTEN stubs (idempotent) ---
    file(READ "${LEAN4_RUNTIME_DIR}/uv/tcp.cpp" _tcp_cpp)
    string(FIND "${_tcp_cpp}" "XEUS_LEAN_PATCHED_TCP" _tcp_has_stub)
    if(_tcp_has_stub EQUAL -1)
        file(APPEND "${LEAN4_RUNTIME_DIR}/uv/tcp.cpp" "
// XEUS_LEAN_PATCHED_TCP - Missing EMSCRIPTEN stubs
#ifdef LEAN_EMSCRIPTEN
namespace lean {
extern \"C\" LEAN_EXPORT lean_obj_res lean_uv_tcp_wait_readable(b_obj_arg socket) {
    lean_always_assert(false && \"Please build a version of Lean4 with libuv to invoke this.\");
}
extern \"C\" LEAN_EXPORT lean_obj_res lean_uv_tcp_try_accept(b_obj_arg socket) {
    lean_always_assert(false && \"Please build a version of Lean4 with libuv to invoke this.\");
}
extern \"C\" LEAN_EXPORT lean_obj_res lean_uv_tcp_cancel_recv(b_obj_arg socket) {
    lean_always_assert(false && \"Please build a version of Lean4 with libuv to invoke this.\");
}
}
#endif
")
    endif()

    # --- Patch udp.cpp: add missing LEAN_EMSCRIPTEN stubs (idempotent) ---
    file(READ "${LEAN4_RUNTIME_DIR}/uv/udp.cpp" _udp_cpp)
    string(FIND "${_udp_cpp}" "XEUS_LEAN_PATCHED_UDP" _udp_has_stub)
    if(_udp_has_stub EQUAL -1)
        file(APPEND "${LEAN4_RUNTIME_DIR}/uv/udp.cpp" "
// XEUS_LEAN_PATCHED_UDP - Missing EMSCRIPTEN stubs
#ifdef LEAN_EMSCRIPTEN
namespace lean {
extern \"C\" LEAN_EXPORT lean_obj_res lean_uv_udp_wait_readable(b_obj_arg socket) {
    lean_always_assert(false && \"Please build a version of Lean4 with libuv to invoke this.\");
}
extern \"C\" LEAN_EXPORT lean_obj_res lean_uv_udp_cancel_recv(b_obj_arg socket) {
    lean_always_assert(false && \"Please build a version of Lean4 with libuv to invoke this.\");
}
}
#endif
")
    endif()

    # --- Patch object.cpp: task manager for WASM single-threaded mode ---
    # The REPL/elaborator uses promises (lean_promise_new / lean_promise_resolve)
    # which assert g_task_manager != nullptr. In single-threaded WASM,
    # g_task_manager is null (no LEAN_MULTI_THREAD, no workers).
    # Fix: remove the assertion in lean_promise_new, and add a null-safe
    # fallback in lean_promise_resolve that resolves synchronously.
    file(READ "${LEAN4_RUNTIME_DIR}/object.cpp" _object_cpp)
    # Patch 1: Remove g_task_manager assertion in lean_promise_new
    string(REPLACE
        "obj_res lean_promise_new() {\n    lean_always_assert(g_task_manager);"
        "obj_res lean_promise_new() {\n    // lean_always_assert(g_task_manager); // patched: allow null for WASM"
        _object_cpp "${_object_cpp}")
    # Patch 2: Add null-safe fallback in lean_promise_resolve
    string(REPLACE
        "void lean_promise_resolve(obj_arg value, b_obj_arg promise) {\n    g_task_manager->resolve(lean_to_promise(promise)->m_result, mk_option_some(value));\n}"
        "void lean_promise_resolve(obj_arg value, b_obj_arg promise) {\n    lean_task_object * t = lean_to_promise(promise)->m_result;\n    object * v = mk_option_some(value);\n    if (g_task_manager) {\n        g_task_manager->resolve(t, v);\n    } else {\n        if (t->m_value) { lean_dec(v); return; }\n        t->m_value = v;\n        lean_task_imp * imp = t->m_imp;\n        t->m_imp = nullptr;\n        free_task_imp(imp);\n    }\n}"
        _object_cpp "${_object_cpp}")
    # Patch 3: Lazy task evaluation for WASM single-threaded mode.
    # When g_task_manager is null and a task has no value yet:
    # - If the task has a closure (from map/bind), execute it lazily
    # - If no closure (unresolved promise), return Option.some(box(0)) as fallback
    string(REPLACE
        "extern \"C\" LEAN_EXPORT b_obj_res lean_task_get(b_obj_arg t) {\n    if (object * v = lean_to_task(t)->m_value)\n        return v;\n    if (g_lean_report_task_get_blocked_time) {\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n        g_task_manager->wait_for(lean_to_task(t));\n        std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();\n        g_lean_report_task_get_blocked_time(std::chrono::nanoseconds(end - start));\n    } else {\n        g_task_manager->wait_for(lean_to_task(t));\n    }\n    lean_assert(lean_to_task(t)->m_value != nullptr);\n    object * r = lean_to_task(t)->m_value;\n    return r;\n}"
        "extern \"C\" LEAN_EXPORT b_obj_res lean_task_get(b_obj_arg t) {\n    if (object * v = lean_to_task(t)->m_value)\n        return v;\n    if (!g_task_manager) {\n        /* WASM single-threaded: lazy task evaluation.\n           If the task has a closure (from map/bind), execute it now.\n           The closure may call lean_task_get on its dependencies,\n           which should already be resolved by this point. */\n        lean_task_imp * imp = lean_to_task(t)->m_imp;\n        if (imp && imp->m_closure) {\n            object * closure = imp->m_closure;\n            lean_inc(closure);\n            object * result = lean_apply_1(closure, lean_box(0));\n            lean_to_task(t)->m_value = result;\n            return lean_to_task(t)->m_value;\n        }\n        /* No closure (unresolved promise with no dependents) - fallback */\n        lean_to_task(t)->m_value = mk_option_some(lean_box(0));\n        return lean_to_task(t)->m_value;\n    }\n    if (g_lean_report_task_get_blocked_time) {\n        std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();\n        g_task_manager->wait_for(lean_to_task(t));\n        std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();\n        g_lean_report_task_get_blocked_time(std::chrono::nanoseconds(end - start));\n    } else {\n        g_task_manager->wait_for(lean_to_task(t));\n    }\n    lean_assert(lean_to_task(t)->m_value != nullptr);\n    object * r = lean_to_task(t)->m_value;\n    return r;\n}"
        _object_cpp "${_object_cpp}")
    # Patch 3b: Fix lean_task_map_core for deferred execution.
    # When g_task_manager is null and the source task has no value yet
    # (e.g., unresolved promise), don't try to run synchronously.
    # Instead, create a task with the closure for lazy evaluation in lean_task_get.
    string(REPLACE
        "extern \"C\" LEAN_EXPORT obj_res lean_task_map_core(obj_arg f, obj_arg t, unsigned prio,\n      bool sync, bool keep_alive) {\n    if (!g_task_manager || (sync && lean_to_task(t)->m_value)) {\n        return lean_task_pure(apply_1(f, lean_task_get_own(t)));\n    } else {"
        "extern \"C\" LEAN_EXPORT obj_res lean_task_map_core(obj_arg f, obj_arg t, unsigned prio,\n      bool sync, bool keep_alive) {\n    if (!g_task_manager) {\n        if (lean_to_task(t)->m_value) {\n            return lean_task_pure(apply_1(f, lean_task_get_own(t)));\n        }\n        /* Source has no value yet (unresolved promise). Create deferred task. */\n        lean_task_object * new_task = alloc_task(mk_closure_3_2(task_map_fn, f, t), sync ? LEAN_SYNC_PRIO : prio, keep_alive);\n        return (lean_object*)new_task;\n    }\n    if (sync && lean_to_task(t)->m_value) {\n        return lean_task_pure(apply_1(f, lean_task_get_own(t)));\n    } else {"
        _object_cpp "${_object_cpp}")
    # Patch 3c: Fix lean_task_bind_core for deferred execution (same as map).
    string(REPLACE
        "extern \"C\" LEAN_EXPORT obj_res lean_task_bind_core(obj_arg x, obj_arg f, unsigned prio,\n      bool sync, bool keep_alive) {\n    if (!g_task_manager || (sync && lean_to_task(x)->m_value)) {\n        return apply_1(f, lean_task_get_own(x));\n    } else {"
        "extern \"C\" LEAN_EXPORT obj_res lean_task_bind_core(obj_arg x, obj_arg f, unsigned prio,\n      bool sync, bool keep_alive) {\n    if (!g_task_manager) {\n        if (lean_to_task(x)->m_value) {\n            return apply_1(f, lean_task_get_own(x));\n        }\n        /* Source has no value yet. Create deferred task. */\n        lean_task_object * new_task = alloc_task(mk_closure_3_2(task_bind_fn1, x, f), sync ? LEAN_SYNC_PRIO : prio, keep_alive);\n        return (lean_object*)new_task;\n    }\n    if (sync && lean_to_task(x)->m_value) {\n        return apply_1(f, lean_task_get_own(x));\n    } else {"
        _object_cpp "${_object_cpp}")
    # Patch 3d: Fix task_map_fn for deferred tasks.
    # When a deferred mapped task is executed lazily (via lean_task_get),
    # the source task's m_value may still be null if the source is a promise
    # that was resolved after the mapped task was created. Call lean_task_get
    # to lazily resolve the source's dependency chain.
    string(REPLACE
        "static obj_res task_map_fn(obj_arg f, obj_arg t, obj_arg w) {\n    b_obj_res v = lean_to_task(t)->m_value;\n    lean_assert(v != nullptr);"
        "static obj_res task_map_fn(obj_arg f, obj_arg t, obj_arg w) {\n    b_obj_res v = lean_to_task(t)->m_value;\n    if (!v) {\n        /* WASM: source task may be an unresolved promise that was resolved\n           after this mapped task was created. Use lean_task_get to lazily\n           evaluate the source's dependency chain. */\n        v = lean_task_get(t);\n    }\n    lean_assert(v != nullptr);"
        _object_cpp "${_object_cpp}")
    # Patch 3e: Fix task_bind_fn1 for deferred tasks (same pattern as task_map_fn).
    string(REPLACE
        "static obj_res task_bind_fn1(obj_arg x, obj_arg f, obj_arg) {\n    b_obj_res v = lean_to_task(x)->m_value;\n    lean_assert(v != nullptr);"
        "static obj_res task_bind_fn1(obj_arg x, obj_arg f, obj_arg) {\n    b_obj_res v = lean_to_task(x)->m_value;\n    if (!v) {\n        v = lean_task_get(x);\n    }\n    lean_assert(v != nullptr);"
        _object_cpp "${_object_cpp}")
    # Patch 4: Null-safe lean_io_check_canceled_core
    string(REPLACE
        "extern \"C\" LEAN_EXPORT bool lean_io_check_canceled_core() {\n    if (lean_task_object * t = g_current_task_object) {\n        lean_assert(t->m_imp); // task is being executed\n        return t->m_imp->m_canceled || g_task_manager->shutting_down();\n    }\n    return false;\n}"
        "extern \"C\" LEAN_EXPORT bool lean_io_check_canceled_core() {\n    if (lean_task_object * t = g_current_task_object) {\n        lean_assert(t->m_imp); // task is being executed\n        return t->m_imp->m_canceled || (g_task_manager && g_task_manager->shutting_down());\n    }\n    return false;\n}"
        _object_cpp "${_object_cpp}")
    # Patch 5: Null-safe lean_io_cancel_core
    string(REPLACE
        "extern \"C\" LEAN_EXPORT void lean_io_cancel_core(b_obj_arg t) {\n    if (lean_to_task(t)->m_value)\n        return;\n    g_task_manager->cancel(lean_to_task(t));\n}"
        "extern \"C\" LEAN_EXPORT void lean_io_cancel_core(b_obj_arg t) {\n    if (lean_to_task(t)->m_value)\n        return;\n    if (g_task_manager) g_task_manager->cancel(lean_to_task(t));\n}"
        _object_cpp "${_object_cpp}")
    # Patch 6: Null-safe deactivate_promise (called when promise is GC'd)
    string(REPLACE
        "void deactivate_promise(lean_promise_object * promise) {\n    g_task_manager->resolve(promise->m_result, mk_option_none());\n    lean_dec_ref((lean_object *)promise->m_result);\n    lean_free_small_object((lean_object *)promise);\n}"
        "void deactivate_promise(lean_promise_object * promise) {\n    if (g_task_manager) {\n        g_task_manager->resolve(promise->m_result, mk_option_none());\n    } else {\n        /* WASM single-threaded: resolve synchronously with none */\n        lean_task_object * t = promise->m_result;\n        if (!t->m_value) {\n            t->m_value = mk_option_none();\n            lean_task_imp * imp = t->m_imp;\n            t->m_imp = nullptr;\n            free_task_imp(imp);\n        }\n    }\n    lean_dec_ref((lean_object *)promise->m_result);\n    lean_free_small_object((lean_object *)promise);\n}"
        _object_cpp "${_object_cpp}")
    # Patch 7: Use frexpf directly instead of C++ frexp(float) overload.
    # emscripten's libc++ wasm64 wrapper generates a frexpf import with i32
    # pointer (wasm32 ABI) instead of i64 (wasm64 ABI), causing a link error.
    string(REPLACE
        "lean_ctor_set(r, 0, lean_box_float32(frexp(a, &exp)));"
        "lean_ctor_set(r, 0, lean_box_float32(frexpf(a, &exp)));"
        _object_cpp "${_object_cpp}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/object.cpp" "${_object_cpp}")

    # --- Fix EMSCRIPTEN stub signature bugs in lean4 source ---
    # These are bugs where the #else (EMSCRIPTEN) branch has a different
    # signature from the header and the non-EMSCRIPTEN implementation.
    # The Python script can't handle #ifdef-branched duplicates.
    file(READ "${LEAN4_RUNTIME_DIR}/uv/dns.cpp" _dns_cpp)
    string(REPLACE
        "lean_uv_dns_get_info(b_obj_arg name, b_obj_arg service, uint8_t family, int8_t protocol) {"
        "lean_uv_dns_get_info(b_obj_arg name, b_obj_arg service, uint8_t family) {"
        _dns_cpp "${_dns_cpp}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/uv/dns.cpp" "${_dns_cpp}")

    file(READ "${LEAN4_RUNTIME_DIR}/uv/system.cpp" _system_cpp)
    string(REPLACE
        "// Std.Internal.UV.System.osGetGroup : IO (Option GroupInfo)\nextern \"C\" LEAN_EXPORT lean_obj_res lean_uv_os_get_group() {"
        "// Std.Internal.UV.System.osGetGroup : IO (Option GroupInfo)\nextern \"C\" LEAN_EXPORT lean_obj_res lean_uv_os_get_group(uint64_t) {"
        _system_cpp "${_system_cpp}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/uv/system.cpp" "${_system_cpp}")

    # --- Fix IO world token signature mismatches (automated) ---
    # The Lean compiler erases IO world tokens when generating C code, but
    # hand-written C++ runtime/stubs include them. In WASM, signature mismatches
    # cause 'unreachable' traps. This script automatically finds and fixes ALL
    # mismatches by comparing Lean-generated C declarations with C++ definitions.
    find_package(Python3 REQUIRED COMPONENTS Interpreter)
    execute_process(
        COMMAND ${Python3_EXECUTABLE} "${_LEANRT_WASM_MODULE_DIR}/fix_extern_signatures.py"
            "${LEAN4_SRC_DIR}/stage0/stdlib"
            "${CMAKE_SOURCE_DIR}/.lake/build/ir"
            --
            "${LEAN4_RUNTIME_DIR}"
            "${LEAN4_SRC_DIR}/src/library"
            "${LEAN4_SRC_DIR}/src/kernel"
            "${LEAN4_SRC_DIR}/src/util"
            "${LEAN4_SRC_DIR}/src/initialize"
            "${_LEANRT_WASM_MODULE_DIR}/stubs"
        RESULT_VARIABLE _fix_sigs_result
        ERROR_VARIABLE _fix_sigs_output
    )
    message(STATUS "fix_extern_signatures: ${_fix_sigs_output}")
    if(NOT _fix_sigs_result EQUAL 0)
        message(FATAL_ERROR "fix_extern_signatures.py failed with code ${_fix_sigs_result}")
    endif()

    # --- Fix return type mismatches (wasm-ld warnings) ---
    # These are C++ declarations/definitions whose return types don't match the
    # stage0 C code. In wasm64, return type mismatches (i32 vs i64) cause
    # wasm-ld to generate trampolines that truncate/zero-extend values.
    # While harmless for boolean values, we fix them to eliminate warnings
    # and potential ABI issues.

    # Patch: lean_kernel_diag_is_enabled - C++ declares uint8* but C returns uint8_t
    file(READ "${LEAN4_SRC_DIR}/src/kernel/environment.cpp" _env_cpp)
    string(REPLACE
        "extern \"C\" uint8* lean_kernel_diag_is_enabled(object*);"
        "extern \"C\" uint8_t lean_kernel_diag_is_enabled(object*);"
        _env_cpp "${_env_cpp}")
    file(WRITE "${LEAN4_SRC_DIR}/src/kernel/environment.cpp" "${_env_cpp}")

    # Patch: lean_io_cancel_token_is_set - C++ declares lean_obj_res but C returns uint8_t
    file(READ "${LEAN4_RUNTIME_DIR}/interrupt.cpp" _interrupt_cpp)
    string(REPLACE
        "extern \"C\" lean_obj_res lean_io_cancel_token_is_set(b_lean_obj_arg cancel_tk);"
        "extern \"C\" uint8_t lean_io_cancel_token_is_set(lean_object* cancel_tk);"
        _interrupt_cpp "${_interrupt_cpp}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/interrupt.cpp" "${_interrupt_cpp}")

    # Patch: llvm_is_declaration - C++ defines lean_object* return but C expects uint8_t
    file(READ "${LEAN4_SRC_DIR}/src/library/llvm.cpp" _llvm_cpp)
    string(REPLACE
        "extern \"C\" LEAN_EXPORT lean_object *llvm_is_declaration(size_t ctx, size_t global) {"
        "extern \"C\" LEAN_EXPORT uint8_t llvm_is_declaration(size_t ctx, size_t global) {"
        _llvm_cpp "${_llvm_cpp}")
    string(REPLACE
        "return lean_box(is_bool);\n#endif  // LEAN_LLVM\n}"
        "return is_bool;\n#endif  // LEAN_LLVM\n}"
        _llvm_cpp "${_llvm_cpp}")
    file(WRITE "${LEAN4_SRC_DIR}/src/library/llvm.cpp" "${_llvm_cpp}")

    # --- Patch hash functor return types for wasm64 ---
    # Hash functors must return std::size_t (64-bit on wasm64) not unsigned (32-bit).
    # With 32-bit return, the upper 32 bits of a 64-bit hash are lost, potentially
    # degrading distribution and causing excessive collisions.
    file(READ "${LEAN4_SRC_DIR}/src/util/name.h" _name_h)
    string(REPLACE
        "struct name_hash_fn { unsigned operator()(name const & n) const { return n.hash(); } };"
        "struct name_hash_fn { std::size_t operator()(name const & n) const { return n.hash(); } };"
        _name_h "${_name_h}")
    file(WRITE "${LEAN4_SRC_DIR}/src/util/name.h" "${_name_h}")

    file(READ "${LEAN4_SRC_DIR}/src/kernel/expr.h" _expr_h)
    string(REPLACE
        "struct expr_hash { unsigned operator()(expr const & e) const { return hash(e); } };"
        "struct expr_hash { std::size_t operator()(expr const & e) const { return hash(e); } };"
        _expr_h "${_expr_h}")
    string(REPLACE
        "unsigned operator()(expr_pair const & p) const { return hash(hash(p.first), hash(p.second)); }"
        "std::size_t operator()(expr_pair const & p) const { return hash(hash(p.first), hash(p.second)); }"
        _expr_h "${_expr_h}")
    file(WRITE "${LEAN4_SRC_DIR}/src/kernel/expr.h" "${_expr_h}")

    file(READ "${LEAN4_SRC_DIR}/src/kernel/level.h" _level_h)
    string(REPLACE
        "struct level_hash { unsigned operator()(level const & n) const { return n.hash(); } };"
        "struct level_hash { std::size_t operator()(level const & n) const { return n.hash(); } };"
        _level_h "${_level_h}")
    file(WRITE "${LEAN4_SRC_DIR}/src/kernel/level.h" "${_level_h}")

    file(READ "${LEAN4_SRC_DIR}/src/library/expr_unsigned_map.h" _exprmap_h)
    string(REPLACE
        "struct expr_unsigned_hash_fn {\n    unsigned operator()(expr_unsigned const & k) const { return k.m_hash; }\n};"
        "struct expr_unsigned_hash_fn {\n    std::size_t operator()(expr_unsigned const & k) const { return k.m_hash; }\n};"
        _exprmap_h "${_exprmap_h}")
    file(WRITE "${LEAN4_SRC_DIR}/src/library/expr_unsigned_map.h" "${_exprmap_h}")

    # Fix sharecommon set_eq to return bool (not std::size_t from lean_sharecommon_eq)
    file(READ "${LEAN4_RUNTIME_DIR}/sharecommon.h" _sharecommon_h)
    string(REPLACE
        "struct set_eq {\n        bool operator()(lean_object * o1, lean_object * o2) const { return lean_sharecommon_eq(o1, o2); }"
        "struct set_eq {\n        bool operator()(lean_object * o1, lean_object * o2) const { return lean_sharecommon_eq(o1, o2) != 0; }"
        _sharecommon_h "${_sharecommon_h}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/sharecommon.h" "${_sharecommon_h}")

    # Fix compact.cpp max_sharing_hash to return std::size_t
    file(READ "${LEAN4_RUNTIME_DIR}/compact.cpp" _compact_cpp)
    string(REPLACE
        "    unsigned operator()(max_sharing_key const & k) const {"
        "    std::size_t operator()(max_sharing_key const & k) const {"
        _compact_cpp "${_compact_cpp}")
    file(WRITE "${LEAN4_RUNTIME_DIR}/compact.cpp" "${_compact_cpp}")

    # Patch ir_interpreter.cpp: Replace dlsym with WASM symbol table lookup.
    # In WASM/emscripten, dlsym doesn't work without -sMAIN_MODULE.
    # We use a generated static lookup table (wasm_symbol_table.cpp) instead.
    # This replaces the dlsym call with a call to wasm_lookup_symbol on LEAN_EMSCRIPTEN,
    # and adds the extern declaration above the function.
    file(READ "${LEAN4_SRC_DIR}/src/library/ir_interpreter.cpp" _interp_cpp)
    # Only patch if not already patched (check for our marker)
    string(FIND "${_interp_cpp}" "wasm_lookup_symbol" _already_patched)
    if(_already_patched EQUAL -1)
        # Add extern declaration before lookup_symbol_in_cur_exe
        string(REPLACE
            "void * lookup_symbol_in_cur_exe(char const * sym) {"
            "// In WASM/emscripten, dlsym doesn't work without -sMAIN_MODULE.\n// Use a generated static lookup table instead.\n#ifdef LEAN_EMSCRIPTEN\nextern \"C\" void* wasm_lookup_symbol(const char* name);\n#endif\n\nvoid * lookup_symbol_in_cur_exe(char const * sym) {"
            _interp_cpp "${_interp_cpp}")
        # Replace dlsym call with LEAN_EMSCRIPTEN-guarded version
        # Original has: #else\n    return dlsym(RTLD_DEFAULT, sym);\n#endif
        # We replace #else with #elif LEAN_EMSCRIPTEN ... #else ... #endif
        string(REPLACE
            "#else\n    return dlsym(RTLD_DEFAULT, sym);\n#endif"
            "#elif defined(LEAN_EMSCRIPTEN)\n    return wasm_lookup_symbol(sym);\n#else\n    return dlsym(RTLD_DEFAULT, sym);\n#endif"
            _interp_cpp "${_interp_cpp}")
        file(WRITE "${LEAN4_SRC_DIR}/src/library/ir_interpreter.cpp" "${_interp_cpp}")
        message(STATUS "Patched ir_interpreter.cpp: dlsym -> wasm_lookup_symbol")
    else()
        message(STATUS "ir_interpreter.cpp already patched for WASM symbol lookup")
    endif()

    # --- Libuv stubs for WASM ---
    # io.cpp and net_addr.cpp reference libuv types/functions in code paths
    # not guarded by #ifndef LEAN_EMSCRIPTEN. We provide a minimal stub uv.h
    # and stub implementations.
    set(LEAN4_UV_STUBS_DIR "${_LEANRT_WASM_MODULE_DIR}/stubs")

    # --- Kernel/library/util source files ---
    # These C++ files implement the Lean kernel (type checker, expressions),
    # library (module loading, IR interpreter), and utility functions.
    # They are needed by the stage0 compiled .c files.
    set(LEAN4_KERNEL_DIR "${LEAN4_SRC_DIR}/src/kernel")
    set(LEAN4_LIBRARY_DIR "${LEAN4_SRC_DIR}/src/library")
    set(LEAN4_UTIL_DIR "${LEAN4_SRC_DIR}/src/util")
    set(LEAN4_INIT_DIR "${LEAN4_SRC_DIR}/src/initialize")

    file(GLOB KERNEL_SOURCES "${LEAN4_KERNEL_DIR}/*.cpp")
    file(GLOB LIBRARY_SOURCES "${LEAN4_LIBRARY_DIR}/*.cpp")
    file(GLOB LIBRARY_CONSTRUCTIONS_SOURCES "${LEAN4_LIBRARY_DIR}/constructions/*.cpp")
    file(GLOB UTIL_SOURCES "${LEAN4_UTIL_DIR}/*.cpp")
    file(GLOB INIT_SOURCES "${LEAN4_INIT_DIR}/*.cpp")

    list(LENGTH KERNEL_SOURCES _kernel_count)
    list(LENGTH LIBRARY_SOURCES _library_count)
    list(LENGTH UTIL_SOURCES _util_count)
    message(STATUS "  Kernel: ${_kernel_count}, Library: ${_library_count}, Util: ${_util_count} source files")

    # --- Runtime source files ---
    # Match lean4's own CMakeLists.txt: src/runtime/CMakeLists.txt
    # All uv/*.cpp files have #ifndef LEAN_EMSCRIPTEN guards with
    # stub implementations in the #else branch.
    set(LEANRT_SOURCES
        ${LEAN4_UV_STUBS_DIR}/uv_stubs.c
        ${LEAN4_UV_STUBS_DIR}/lean_wasm_stubs.cpp
        ${KERNEL_SOURCES}
        ${LIBRARY_SOURCES}
        ${LIBRARY_CONSTRUCTIONS_SOURCES}
        ${UTIL_SOURCES}
        ${INIT_SOURCES}
        ${LEAN4_RUNTIME_DIR}/debug.cpp
        ${LEAN4_RUNTIME_DIR}/thread.cpp
        ${LEAN4_RUNTIME_DIR}/mpz.cpp
        ${LEAN4_RUNTIME_DIR}/utf8.cpp
        ${LEAN4_RUNTIME_DIR}/object.cpp
        ${LEAN4_RUNTIME_DIR}/apply.cpp
        ${LEAN4_RUNTIME_DIR}/exception.cpp
        ${LEAN4_RUNTIME_DIR}/interrupt.cpp
        ${LEAN4_RUNTIME_DIR}/memory.cpp
        ${LEAN4_RUNTIME_DIR}/stackinfo.cpp
        ${LEAN4_RUNTIME_DIR}/compact.cpp
        ${LEAN4_RUNTIME_DIR}/init_module.cpp
        ${LEAN4_RUNTIME_DIR}/io.cpp
        ${LEAN4_RUNTIME_DIR}/hash.cpp
        ${LEAN4_RUNTIME_DIR}/byteslice.cpp
        ${LEAN4_RUNTIME_DIR}/platform.cpp
        ${LEAN4_RUNTIME_DIR}/alloc.cpp
        ${LEAN4_RUNTIME_DIR}/allocprof.cpp
        ${LEAN4_RUNTIME_DIR}/sharecommon.cpp
        ${LEAN4_RUNTIME_DIR}/stack_overflow.cpp
        ${LEAN4_RUNTIME_DIR}/process.cpp
        ${LEAN4_RUNTIME_DIR}/object_ref.cpp
        ${LEAN4_RUNTIME_DIR}/mpn.cpp
        ${LEAN4_RUNTIME_DIR}/mutex.cpp
        ${LEAN4_RUNTIME_DIR}/libuv.cpp
        ${LEAN4_RUNTIME_DIR}/uv/net_addr.cpp
        ${LEAN4_RUNTIME_DIR}/uv/event_loop.cpp
        ${LEAN4_RUNTIME_DIR}/uv/timer.cpp
        ${LEAN4_RUNTIME_DIR}/uv/tcp.cpp
        ${LEAN4_RUNTIME_DIR}/uv/udp.cpp
        ${LEAN4_RUNTIME_DIR}/uv/dns.cpp
        ${LEAN4_RUNTIME_DIR}/uv/system.cpp
        ${LEAN4_RUNTIME_DIR}/uv/signal.cpp
    )

    # --- Build libleanrt_wasm ---
    add_library(leanrt_wasm STATIC ${LEANRT_SOURCES})

    target_include_directories(leanrt_wasm PUBLIC
        ${LEAN4_UV_STUBS_DIR}  # stub uv.h for WASM (must be before system includes)
        ${LEAN4_INCLUDE}
        ${LEAN4_SRC_DIR}/src  # for "runtime/object.h" style includes
    )

    target_compile_definitions(leanrt_wasm PRIVATE
        LEAN_EXPORTING
        LEAN_EMSCRIPTEN
        NDEBUG
    )

    target_compile_options(leanrt_wasm PRIVATE
        -fPIC
        -O2
        -g2
        -Wno-unused-parameter
        -Wno-deprecated
        -Wno-sign-compare
        -Wno-missing-field-initializers
        -Wno-unused-variable
        -Wno-unused-but-set-variable
    )

    # GMP: build mini-gmp from GMP source for wasm64 compatibility
    # mini-gmp is a portable, single-file GMP subset that works on any platform.
    # Full GMP uses arch-specific assembly; mini-gmp is pure C.
    set(GMP_VERSION "6.3.0")
    FetchContent_Declare(gmp
        URL "https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VERSION}.tar.xz"
        DOWNLOAD_EXTRACT_TIMESTAMP TRUE)
    FetchContent_GetProperties(gmp)
    if(NOT gmp_POPULATED)
        FetchContent_Populate(gmp)
    endif()

    set(MINI_GMP_DIR "${gmp_SOURCE_DIR}/mini-gmp")
    if(EXISTS "${MINI_GMP_DIR}/mini-gmp.c")
        # Build mini-gmp as a static library
        add_library(mini-gmp STATIC "${MINI_GMP_DIR}/mini-gmp.c")
        target_include_directories(mini-gmp PUBLIC "${MINI_GMP_DIR}")
        target_compile_options(mini-gmp PRIVATE -O2 -fPIC)

        # Create a gmp.h shim that includes mini-gmp.h
        # (lean4 #includes <gmp.h>, mini-gmp provides mini-gmp.h)
        set(GMP_SHIM_DIR "${CMAKE_CURRENT_BINARY_DIR}/gmp-shim")
        file(MAKE_DIRECTORY "${GMP_SHIM_DIR}")
        file(WRITE "${GMP_SHIM_DIR}/gmp.h"
            "#pragma once\n#include \"mini-gmp.h\"\n")

        target_link_libraries(leanrt_wasm PUBLIC mini-gmp)
        target_include_directories(leanrt_wasm PUBLIC "${GMP_SHIM_DIR}" "${MINI_GMP_DIR}")
        target_compile_definitions(leanrt_wasm PUBLIC LEAN_USE_GMP)
        message(STATUS "mini-gmp ${GMP_VERSION} configured for wasm64")
    else()
        message(WARNING "mini-gmp not found in GMP source - .olean files will be incompatible")
    endif()

    # Return values
    set(${out_lib} leanrt_wasm PARENT_SCOPE)
    set(${out_include_dir} ${LEAN4_INCLUDE} PARENT_SCOPE)

    message(STATUS "libleanrt_wasm configured (${CMAKE_CURRENT_BINARY_DIR})")
endfunction()
